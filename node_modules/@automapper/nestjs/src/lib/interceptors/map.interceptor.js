"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapInterceptor = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@nestjs/common");
const operators_1 = require("rxjs/operators");
const di_1 = require("../di");
const utils_1 = require("../utils");
exports.MapInterceptor = utils_1.memoize(createMapInterceptor);
function createMapInterceptor(to, from, options) {
    const { isArray, mapperName, transformedMapOptions } = utils_1.getTransformOptions(options);
    let MixinMapInterceptor = class MixinMapInterceptor {
        constructor(mapper) {
            this.mapper = mapper;
        }
        intercept(context, next) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (utils_1.shouldSkipTransform(this.mapper, to, from)) {
                    return next.handle();
                }
                try {
                    return next.handle().pipe(operators_1.map((response) => {
                        var _a;
                        if (isArray) {
                            return utils_1.transformArray(response, this.mapper, to, from, transformedMapOptions);
                        }
                        return (_a = this.mapper) === null || _a === void 0 ? void 0 : _a.map(response, to, from, transformedMapOptions);
                    }));
                }
                catch (_a) {
                    return next.handle();
                }
            });
        }
    };
    MixinMapInterceptor = tslib_1.__decorate([
        tslib_1.__param(0, common_1.Optional()),
        tslib_1.__param(0, di_1.InjectMapper(mapperName)),
        tslib_1.__metadata("design:paramtypes", [Object])
    ], MixinMapInterceptor);
    return common_1.mixin(MixinMapInterceptor);
}
//# sourceMappingURL=map.interceptor.js.map